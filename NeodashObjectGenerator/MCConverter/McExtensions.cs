using System.Numerics;
using NeodashObjectGenerator.Gen;
using NeodashObjectGenerator.Gen.Components;
using NeodashObjectGenerator.Minecraft;

namespace NeodashObjectGenerator.MCConverter;

// Some useful extensions
public static class McExtensions
{
    // Get the source code string that constructs a given vector
    public static string ConstructorString(this Vector3 v)
    {
        return $"new Vector3({v.ComponentString()})";
    }

    // Get comma-separated components of a vector
    public static string ComponentString(this Vector3 v)
    {
        return $"{v.X}f, {v.Y}f, {v.Z}f";
    }
    
    // Convert from the minecraft coordinate system (right-handed) to the neodash coordinate system (left-handed)
    public static Vector3 McToNeodash(this Location loc) => new(loc.X, loc.Z, loc.Y);

    // Rotate a vector clockwise
    public static Vector3 Clockwise(this Vector3 v, Vector3 origin = default)
    {
        v -= origin;
        return v with {X = -v.Y, Y = v.X} + origin;
    }
    
    // Rotate a location clockwise
    public static Location Clockwise(this Location v)
    {
        return v with {X = -v.Z, Z = v.X};
    }

    // Get a property from a tag
    public static Tag Prop(this Tag tag, string property)
    {
        return tag["Properties"][property];
    }

    // Attempt to get a property that might not exist
    public static bool TryGetProp(this Tag tag, string property, out Tag value)
    {
        if (tag is not TagCompound tc)
        {
            value = default;
            return false;
        }
        if (!tc.Payload.TryGetValue("Properties", out var props))
        {
            value = default;
            return false;
        }
        return props.TryGetValue(property, out value);
    }
    
    // Get the component-wise minimum of two vectors
    public static Vector3 Min(this Vector3 a, Vector3 b) => new(Math.Min(a.X, b.X), Math.Min(a.Y, b.Y), Math.Min(a.Z, b.Z));

    // Get the component-wise maximum of two vectors
    public static Vector3 Max(this Vector3 a, Vector3 b) => new(Math.Max(a.X, b.X), Math.Max(a.Y, b.Y), Math.Max(a.Z, b.Z));

    // Create a shift offset. The given offset values are a number of whole blocks to shift
    public static Vector3 Shift(this SimpleWorld world, float x, float y, float z)
    {
        return new Vector3(x, y, z) * Sizes.BlockSize * world.WorldScale;
    }

    // Create a shift from a vector
    public static Vector3 ToShift(this SimpleWorld world, Vector3 blockOffset)
    {
        return blockOffset * Sizes.BlockSize * world.WorldScale;
    }

    // Apply a default style to cubes
    public static void DefaultCubeStyle(Cube cube)
    {
        cube.NoBand();
    }

    // Create a cube at the given location
    public static Cube MakeCube(this SimpleWorld world, Location location, int group = -1, Cube.Style style = Cube.Style.Edges)
    {
        var c = new Cube(style, world.BlockToWorld(location), Vector3.Zero, world.WorldScale, group < 0 ? world.NextGroup() : group);
        DefaultCubeStyle(c);
        return c;
    }
    
    // Create a partial cube, i.e. a cube that does not occupy a full block, at the given location.
    // lower and upper are the two corners of the sub-cube, in block coordinates.
    // For example, if the corners are [0, 0, 0] and [1, 1, 1] then a standard full block is generated.
    // Likewise a half-slab would be generated by [0, 0, 0] and [1, 1, 0.5]
    // The corners do not necessarily need to be contained within the cube.
    public static Cube MakePartialCube(this SimpleWorld world, Location location, Vector3 lower, Vector3 upper, int group = -1, Cube.Style style = Cube.Style.Edges)
    {
        var min = lower.Min(upper);
        var max = lower.Max(upper);
        // Find the center of the sub-cube in block coordinates
        var offset = (min + max) / 2 - Vector3.One / 2;
        var scale = max - min;
        var c = new Cube(style,
            world.BlockToWorld(location) + world.ToShift(offset),
            Vector3.Zero,
            world.WorldScale * scale,
            group < 0 ? world.NextGroup() : group);
        DefaultCubeStyle(c);
        return c;
    }
    
    // Same as above but applies rotation to the cube as well.
    // The extra parameters for rotation define the amount to rotate the cube and the order of rotation.
    // Rotation is in degrees and applied to the cube, but each component should be a multiple of 90.
    // The scale of the cube is adjusted to fit into the same space as originally specified by the two corners
    // after rotation. Specifying a custom rotation order may be required to get the desired rotation.
    // Rotation order is a string containing the characters X, Y, and Z, in the order to apply them to the scale.
    public static Cube MakePartialCube(this SimpleWorld world, Location location, Vector3 rotation, string rotOrder, Vector3 lower, Vector3 upper, int group = -1, Cube.Style style = Cube.Style.Edges)
    {
        var min = lower.Min(upper);
        var max = lower.Max(upper);
        var offset = (min + max) / 2 - Vector3.One / 2;
        var scale = max - min;

        rotOrder ??= "XYZ";
        var rotationLoc = new Location((int) (rotation.X / 90) & 3, (int) (rotation.Y / 90) & 3, (int) (rotation.Z / 90) & 3);
        foreach (var ch in rotOrder)
        {
            if (ch == 'X')
            {
                for (var i = 0; i < rotationLoc.X; i++)
                {
                    scale = scale with {Y = scale.Z, Z = scale.Y};
                }
            }
            else if (ch == 'Y')
            {
                for (var i = 0; i < rotationLoc.Y; i++)
                {
                    scale = scale with {X = scale.Z, Z = scale.X};
                }
            }
            else if (ch == 'Z')
            {
                for (var i = 0; i < rotationLoc.Z; i++)
                {
                    scale = scale with {X = scale.Y, Y = scale.X};
                }
            }
        }

        var c = new Cube(style,
            world.BlockToWorld(location) + world.ToShift(offset),
            rotation,
            world.WorldScale * scale,
            group < 0 ? world.NextGroup() : group);
        DefaultCubeStyle(c);
        return c;
    }

    // Define a default style for spikes
    public static void DefaultSpikeStyle(Spikes s)
    {
        s.AddGlowIntensity(0.15f);
    }

    // Set up a direction context so that the generated component has a rotation applied to it.
    // The defined function only needs to define how to generate the object when facing the positive X-axis,
    // and the resulting object will be rotated according to the direction parameter.
    public static T MakeFacing<T>(this SimpleWorld world, int direction, Func<DirectionContext, T> func)
    {
        world.Context.Reset();
        world.Context.Clockwise = direction;
        return func(world.Context);
    }
}